-------------------------------------------------------------------

1.2 - https://stepik.org/media/attachments/lesson/12527/lesson.pdf
Internet - глобальная сеть передачи данных
Среда для передачи данных между двумя компьютерами
Протоколы
• HTTP, SSH, P2P - прикладные протоколы
• DNS - система имен
• TCP - надежная последовательная передача данных	
• IP - глобальная адресация, передача в гетерогенной среде
4 байта уникальная идентификация в сети (не надеждая передача)

WWW - множество взаимосвязанных документов,
располагающихся на машинах подключенных к Internet
WWW - набор протоколов, серверного и клиентского ПО,
позволяющих получать доступ к документам

Типы документов (MIME-типы)
• text/html
• text/css
• text/javascript
• image/png
• video/mp4
• text/xml
• application/json
Расширения файлов играют второстепенную роль

Документы могут быть
• Статические
	Это файлы на дисках сервера
 	Как правило, обладают постоянным адресом
• Динамические
 	Создаются на каждый запрос
 	Содержимое зависит от времени и пользователя
 	Адрес может быть постоянным или меняться

URL - unified resource locator
http://server.org:8080/path/doc.html?a=1&b=2#part1
• http - протокол
• server.org - DNS имя сервера
• 8080 - TCP порт
• /path/doc.html - путь к файлу
• a=1&b=2 - опции запроса
• part1 - якорь, положение на странице

Абсолютные и относительные URL
• http://server.org/1.html - абсолютный
• //server.org/1.html - абсолютный (schemeless)
• /another/page.html?a=1 - относительный (в пределах домена)
• pictures/1.png - относительный (от URL текущего документа)
• ?a=1&b=2 - относительный (от URL текущего документа)
• #part2 - относительный (в пределах текущего документа)

Правила разрешения URL
https://site.com/path/page.html - основной документ
+ http://wikipedia.org = http://wikipedia.org
+ //cdn.org/jquery.js = https://cdn.org/jquery.js
+ /admin/index.html = https://site.com/admin/index.html
+ another.html = https://site.com/path/another.html
+ ?full=1 = https://site.com/path/page.html?full=1
+ #chapter2 = https://site.com/path/page.html#chaprer2

Клиент-серверная архитектура
Web-клиенты работают на компьютерах конечных пользователей.
Задача Web-клиентов состоит в получении и отображении
документов.
Web-сервера работают (как правило) на серверах в датацентрах.
Их задача заключается в хранении (или генерации) и отдачи
документов.

-------------------------------------------------------------------

1.3 - https://stepik.org/media/attachments/lesson/12528/lesson.pdf
Разновидности web-клиентов
• Библиотеки в ЯП: libcurl, urllib, и т.д.
• Консольные утилиты: wget, curl, telnet!
• Роботы: поисковики, вредоносные скрипты
• Браузеры:
• Полноценные: firefox, chrome и т.д.
• Встроенные: web-view, webkit и т.д.

Особенности библиотек webклиентов
• Предоставляют максимум опций для работы с HTTP
• Осуществляют кодирование / декодирование данных
• Перенаправления, куки - опционально
Назначение: используются внутри других программ для простой
работы c HTTP

Назначение консольных клиентов
• Автоматизация в shell-скриптах
• Создание "статической копии сайта"
• Отладка web-приложений

Telnet - это простейшее средство отладки. telnet открывает tcp
соединение и связывает его с консолью, позволяя общаться с 
webсервером напрямую с клавиатуры.

Еще примеры отладки
GET запрос к серверу с отображением всех заголовков:
curl -vv 'http://api.site.com/method/?arg=1'
POST запрос к серверу с авторизацией и передачей доп.
заголовков:
curl -vv -d 'arg=1' -H'X-Token: 123'
'http://api.site.com/method/'

Браузер
Сценарий работы web приложения
• Пользователь вводит URL
• Браузер загружает Web страницу - HTML документ
• Браузер анализирует (parse) HTML и загружает доп. ресурсы
• Браузер отображает (rendering) HTML страницу
• Пользователь переходит по гиперссылке или отправляет форму
• Цикл повторяется

Сценарий работы современного
приложения
• Браузер загружает Web страницу, ресурсы и отображает ее
• JavaScript загружает данные с помощью AJAX запросов
• JavaScript обеспечивает полноценный UI на странице
• Пользователь взаимодействуюет с UI, что приводит к вызову
JavaScript обработчиков
• JavaScript обновляет данные на сервере или загружает новые
данные, используя AJAX

Особенности современных Webприложений
• UI находится на 1 или нескольких страницах (one-page)
• UI полностью статичен: HTML, CSS, JS - статические файлы
• Логика UI полностью работает на стороне клиента
• Используется шаблонизация в JavaScript
• Application сервер возвращает чистые данные (JSON или XML, а не
HTML)

-------------------------------------------------------------------

1.4 - https://stepik.org/media/attachments/lesson/14820/lesson.pdf
HTML
Особенности HTML разметки
• Произвольный регистр: <BR> == <br>
• Атрибуты без скобок: color=red
• Сокращенные атрибуты: disabled
• Непарные тэги: <p> вместо <p></p>
• Перестановки тэгов: <b><i></b></i>
• «Свои» тэги: <magic></magic>

Особенности XHTML разметки
• Только нижний регистр тэгов
• Атрибуты со скобками: color=”red”
• Атрибуты – без сокращений: disabled=”disabled”
• Тэги всегда парные: <p></p>
• Строгая вложенность: <i><b></b></i>
• id вместо name
• Необходим DOCTYPE

DOCTYPE
DOCTYPE уточняет тип содержимого, указывает HTML парсеру как
правильно разбирать данный документ.
XHTML 1.1
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
HTML 4 Transitional
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01
Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
HTML5
<!DOCTYPE html>

Тэги верхнего уровня
• html - обертка
• head - заголовок страницы, не отображается
• body - тело страницы, то, что видит пользователь
Тэги внутри head
• title - отображается в заголовке окна браузера
• meta - содержит информацию для user-agentов
<meta name="description" content="Для друзeй">
<meta http-equiv="Content-Type" content="text/html;
charset=utf-8">
link - указание связанных ресурсов, например CSS
<link rel="stylesheet" href="/style.css">
<link rel="alternate" href="/news.rss"
type="application/rss+xml">
• script - загрузка JavaScript
<script src="./jquery.js" charset="windows-1251" async>
</script>

Рекомендацим по link и script
Загрузку CSS (тэг link ) рекомендуется ставить в тэге head , а
загрузку JavaScript (тэг script ) - наоборот ближе к концу
странице. Это повышает скорость отрисовки страницы.

Блочные тэги
• h1 - h6 ― различные уровни заголовков
• p ― разбиение текста на параграфы
• hr ― горизонтальная линия
• pre ― блок преформатированного кода, например исходный код
• blockquote ― цитирование длинного блока текста
• div ― абстрактный блочный контейнер

Строчные тэги
• a ― гиперссылки
• em , i ― акцентирование
• strong , b ― выделение
• img ― вставка изображений
• sub ― нижний индекс
• sup ― верхний индекс
• span ― абстрактный строчный контейнер

Списки в HTML
ul , ol , li - маркированные списки
<ul>
<li><code>a</code> ― гиперссылки</li>
<li><code>em</code> ― акцентирование</li>
</ul>

Таблицы 
table, tr, td

Гиперссылки
<a href="http://duckduckgo.com" target="_blank">
<img src="duck.png">
</a>
• href - URL гиперссылки
• target - в каком окне открывать ссылку
• name - имя якоря, вместо href

Действия браузера при переходе
Поведение браузера зависит от протокола в URL
• http , https , ftp - переход по ссылке
• mailto - запуск почтового клиента
• javascript - выполнение JavaScript кода
• #anchor - прокрутка текущей страницы

Формы
<form method="POST" action="/add/"
enctype="multipart/form-data" target="frame3">
<input name="image" type="file">
<input name="id" type="hidden" value="3">
<input name="nick" type="text">
<input type="submit" value="Отправить">
<button type="submit" name="action" value="more">
Все равно отправить
</button>
</form>

Аттрибуты формы
• action - URL, на который будет отправлена форма
• metod - HTTP метод, GET или POST
• target - имя окна браузера, в котором открыть результат
• enctype - способ кодирования данных формы. По умолчанию -
application/x-www-form-urlencoded . Если форма содержит
поля для ввода файлов, то должно быть multipart/form-data

application/x-www-form-urlencoded
Это способ кодирования данных формы для передачи через URL.
Допустим есть форма со следующими данными:
id: 3
name: Вася
friend_id: [4, 5]
В закодированном виде это буде выглядеть так:
id=3&name=%D0%92%D0%B0%D1%81%D1%8F&friend=4&friend=5

Элементы ввода формы
• input - универсальное поле, может быть:
• type="hidden" - невидимое
• type="text" - текстовое поле
• type="password" - вместо текста будет отображатся *
• type="checkbox" - checkbox, переключатель да/нет 
• type="radio"
• button - кнопка
• textarea - многострочное поле ввода
• select , option - выпадающий список

Атрибуты элементов ввода
type - определяет внешний вид и функционал
• name - имя, с которым данный элемент попадет в запрос
• value - начальное знаечение, пользователь может изменить
• placeholder - подсказка для пользователя

-------------------------------------------------------------------

1.5 - https://stepik.org/media/attachments/lesson/14821/lesson.pdf
CSS
Как задать оформление страницы ?
HTML, в отличие от XML, обладает семантикой, т.е. браузер знает
как отображать тот или иной HTML тэг. В HTML есть тэги для
управления внешним видом ( color , font , big , ...), но их
возможности явно недостаточны.
Решение - описывать внешний вид отдельно от структуры
документа c помощью языка Cascading Style Sheets.

Где могут быть заданы стили?
• Встроенные в браузер стили
• Во внешнем файле
<link rel="stylesheet" href="style.css">
• В коде HTML документа
<style>...</style>
• Стили могут быть привязаны к конкретному тэгу
<img style="margin: 3px" src="...">

Какие бывают стили ?
• width , height ― размеры элемента
• margin , padding ― границы и отступы
• display , visibility ― режим отображения
• top , left , right , bottom ― расположение
• background ― фон элемента
• font ― управление шрифтом
• text-align ― выравнивание текста

Классы и идентификаторы
<div id="userpic"><img src="..."></div>
<button class="btn btn-main">Одобрить</div>
<button class="btn">Написать комментарий</div>
• id - идентификатор элемента, должен быть уникален на странице
• class - список классов элемента, классы могут повторяться

Базовые селекторы
• Универсальный селектор
* { margin: 0px; padding: 0px; border: 0px; }
• Имена тэгов
p { margin-top: 10px; }
• Имена классов (с точки)
.btn { border: solid 1px gray; }
• id тэгов (с решетки)
#userpic { padding: 10px }

Сложные селекторы
• контекстные (вложенные)
div.article a { text-decoration: underline }
• дочерние (вложенность = 1 уровень)
a > img { border: 2px }
• соседние
h2.sic + p { margin-left: 30px }
• группировка
h1, h2 { color: red }

Псевдоклассы
• a:visited ― посещенная ссылка
• a:link ― непосещенная ссылка
• div:hover ― элемент при наведении мыши
• input:focus ― элемент при получении фокуса
• li:first-child ― выбирает первого потомка среди множества
элементов

Псевдоэлементы
• #el:after ― виртуальный элемент сразу после #el
• #el:before ― виртуальный элемент непосредственно перед #el
.jack-sparrow:before {
content: "Captain ";
display: inline;
}

Приоритеты стилей
В случае, если два разных стиля конфликтуют между собой,
применяется тот, что обладает большей специфичностью. Если
специфичность двух стилей совпадает, применяется тот, что
расположен ниже в HTML/CSS коде.
Указание в значение стиля флага !important позволяет
перекрыть проверку специфичности.

Правила расчета специфичности
• id – 100
• классы и псевдоклассы – 10
• тэги и псевдоэлементы – 1
Так, например, селектор ul.info ol + li обладает
специфичностью 13, а селектор li.red.level специфичностью
21 балл

Режимы отображения элементов
• display: none ― элемент невидим, не занимает места
• display: block ― элемент занимает максимальную ширину,
начинается с новой строки, учитывает width, height
• display: inline ― элемент занимает минимальную ширину, и
не прерывает строку, игнорирует width, height
• display: inline-block ― блочный элемент, но не разрывает
строку, примерно как img

float: left - всплывание влево, float: right - всплывание
вправо, clear: both - отменяет всплывание, «проводит черту»

Позиционирование
• position: static ― обычное расположение
• position: relative ― смещение относительно начального
местоположения на странице
• position: absolute ― если родитель relative, absolute или fixed
– относительно родителя, иначе - относительно начала документа
• position: fixed ― относительно окна браузера
• top/right/bottom/left - отступы, могут быть отрицательными

Что такое Bootstrap?
Bootstrap - это готовая библиотека стилей (CSS-фреймворк) от
Twitter. Bootstrap позволяет быстро разработать приемлемый
дизайн даже при базовых знаниях CSS.

Что включает в себя Bootstrap?
• Шаблон страниц
• Сетка
• Современные «стили по умолчанию»
• Верстка: таблицы, формы, списки, кнопки, …
• Компоненты: навигация, меню, пагинатор, …
• JavaScript плагины

Сетка Bootstrap
<div class="row">
<div class="col-md-4 col-lg-2">LEFT</div>
<div class="col-md-8 col-lg-10">CONTENT</div>
</div>

-------------------------------------------------------------------

1.6* - https://stepik.org/media/attachments/lesson/14823/lesson.pdf
Как происходит HTTP запрос ?
• Браузер анализирует введенный URL и извлекает имя хоста
• Используя систему DNS, браузер преобразует домен в ip адрес
• Устанавливает TCP соединение с web-сервером
• Если протокол https, устанавливает TLS соединение поверх TCP
• Формирует HTTP запрос, отправляет его, HTTP ответ
• Браузер закрывает соединение (для HTTP/1.0)
• Далее процесс парсинга и отображения документа ...

Domain Name System
DNS - это распределенная база данных, хранящая информацию о
доменах, в первую очередь отображение доменных имен на IP
адреса машин, обслуживающих эти домены

Домены и зоны
База DNS разделена на зоны. Каждая зона находится под единым
административным контролем. Проще говоря обслуживается
одной организацией.
Хранение информации о доменах более высокого уровня может
быть делегировано другим зонам.

Что содержит зона DNS сервера ?
• A - IPv4 адрес(а) для данного домена
• AAAA - IPv6 адрес(а)
• NS - адрес(a) DNS серверов обслуживающих данную зону
• MX - адрес(а) почтовых серверов для данного домена

Зачем нужен TCP ?
TCP - протокол, обеспечивающий надежную последовательную
доставку данных. Фактически, TCP предоставляет интерфейс,
похожий на файловый ввод/вывод для сетевых соединений.
• Надежная доставка
• Полнодуплексная передача
• Контроль потока - защита от переполнения

TCP порты
TCP порт - это «адрес» сетевого соединения в пределах одного
хоста. TCP порты позволяют поддерживать множество открытых
соединений на одной машине.
Номер порта - целое число, не больше 65535. Порты ниже 1024
требуют привилегий суперпользователя для использования.

Стандартные TCP порты
• 20,21 - FTP
• 22 - SSH
• 25 - SMTP
• 80 - HTTP
• 443 - HTTPS

Пример TCP клиента
import socket
req = "Hello tcp!"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 1234))
s.send(req)
rsp = s.recv(1024)
s.close()

Пример TCP сервера - echo
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('127.0.0.1', 1234))
s.listen(10)
while True:
conn, addr = s.accept()
while True:
data = conn.recv(1024)
if not data: break
conn.send(data)
conn.close()

Как правильно читать данные из
сокета ?
def myreceive(sock, msglen):
msg = ''
while len(msg) < msglen:
chunk = sock.recv(msglen-len(msg))
if chunk == '':
raise RuntimeError("broken")
msg = msg + chunk
return msg

Как правильно записывать данные
в сокет ?
def mysend(sock, msg):
totalsent = 0
while totalsent < len(msg):
sent = sock.send(msg[totalsent:])
if sent == 0:
raise RuntimeError("broken")
totalsent = totalsent + sent


TLS - Transport Layer Security
TLS (а ранее SSL) - криптографический протокол, обеспечивающий
безопасную передачу данных между хостами в Internet.
• Аутентификация сервера (и клиента)
• Шифрование и сжатие передаваемой информации
• Защита от подмены и проверка целостности сообщений

ClientHello - клиент указывает желаемые опции соединения
• ServerHello - сервер подтверждает опции соединения
• Certificate - сервер посылает клиенту свой сертификат
• Клиент проверяет сертификат.
На данном этапе соединение может быть отклонено
• ClientKeyExchange - клиент отправляет серверу ключ
симметричного шифрования (или параметры для его генерации)
• Finished - сервер подтверждает завершение рукопожатия

Неутешительный вывод
Установление TCP и TLS соединения требует существенного
времени. Минимум 1 RTT для TCP соединения и 1-2 RTT для TLS
соединения.
Под RTT понимается Round Trip Time - время, необходимое для
передачи IP дейтаграммы к серверу и обратно.

-------------------------------------------------------------------

1.7 - https://stepik.org/media/attachments/lesson/14824/lesson.pdf
Какие задачи решает HTTP?
• Передача документов
• Передача мета-информации
• Авторизация
• Поддержка сессий
• Кеширование документов
• Согласование содержимого (negotiation)
• Управление соединением

Ключевые особенности HTTP
• Работает поверх TCP/TLS
• Протокол запрос-ответ
• Не поддерживает состояние (соединение) - stateless
• Текстовый протокол
• Расширяемый протокол

HTTP/1.0 запрос
GET http://www.ru/robots.txt HTTP/1.0
Accept: text/html, text/plain
User-Agent: telnet/hands
If-Modified-Since: Fri, 24 Jul 2015 22:53:05 GMT
Перевод строки - \r\n

HTTP/1.1 запрос
GET /robots.txt HTTP/1.1
Accept: text/html,application/xhtml+xml
Accept-Encoding: gzip, deflate
Cache-Control: max-age=0
Connection: keep-alive
Host: www.ru
User-Agent: Mozilla/5.0 Gecko/20100101 Firefox/39.0

HTTP/1.1 ответ
HTTP/1.1 404 Not Found
Server: nginx/1.5.7
Date: Sat, 25 Jul 2015 09:58:17 GMT
Content-Type: text/html; charset=iso-8859-1
Connection: close
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>...

HTTP запрос состоит из
• строка запроса
• метод
• URL документа
• версия
• заголовки
• тело запроса

HTTP методы
• GET - получение документа
• HEAD - получение только заголовков
• POST - отправка данных на сервер
• PUT - отправка документа на сервер (*)
• DELETE - удаление документа (*)
• CONNECT, TRACE, OPTIONS - используются редко (*)
• COPY, MOVE, MKCOL - расширения WebDAV (*)

HTTP ответ состоит из
• строка ответа
• метод
• URL документа
• версия
• заголовки
• тела ответа - документ

HTTP коды ответа
• 1xx - информационные
• 2xx - успешное выполнение
• 3xx - перенаправления
• 4xx - ошибка на стороне клиента
• 5xx - ошибка на стороне сервера

HTTP коды ответа (1)
• 200 OK - запрос успешно выполнен
• 204 No Content - запрос успешно выполнен, но документ пуст
• 301 Moved Permanently - документ сменил URL
• 302 Found - повторить запрос по другому URL
• 304 Not Modified - документ не изменился, использовать кеш

HTTP коды ответа (2)
• 400 Bad Request - неправильный синтаксис запроса
• 401 Unauthorized - требуется авторизация
• 403 Forbidden - нет доступа (неверная авторизация)
• 404 Not Found - документ не найден
• 500 Internal Server Error - неожиданная ошибка сервера (application)
• 502 Bad Gateway - проксируемый сервер отвечает с ошибкой
• 504 Gateway Timeout - проксируемый сервер не отвечает

Заголовки HTTP (общие)
Для управления соединением и форматом сообщения (документа)
• Content-Type - MIME тип документа
• Content-Length - длина сообщения
• Content-Encoding - кодирование документа, например gzip-сжатие
• Transfer-Encoding - формат передачи, например, chunked
• Connection - управление соединением
• Upgrade - смена протокола

Заголовки HTTP запросов
• Authorization - авторизация, чаще всего логин/пароль
• Cookie - передача состояния (сессии) на сервер
• Referer - URL предыдущего документа, контекст запроса
• User-Agent - описание web-клиента, версия браузера
• If-Modified-Since - условный GET запрос
• Accept-* - согласование (negotiation) содержимого

Заголовки HTTP ответов
• Location - новый URL документа при перенаправлениях
• Set-Cookie - установка состояния (сессии) в браузере
• Last-Modified - дата последнего изменения документа
• Date - Дата на сервере, для согласования кешей
• Server - описание web-сервера, название и версия

Общие принципы
Протокол HTTP/1.0 предполагает закрытие TCP соединения сразу
после ответа сервера.
Протокол HTTP/1.1 предполагает удержание TCP соединения, если
не было заголовка Connection: close .

Логика управления в HTTP/1.1
Соединение должно быть закрыто, если:
• cервер или клиент использует HTTP младше 1.1
• cервер или клиент передал заголовок Connection: close
• по истечении таймаута (обычно небольшой, около 10с)
Иначе соединение остается открытым для последующих запросов.

-------------------------------------------------------------------

1.8 - https://stepik.org/media/attachments/lesson/14825/lesson.pdf
Web сервера
APACHE - NGIN - LIGHTTPD - IIS7
Запуск web сервера
• Команда на запуск
sudo /etc/init.d/nginx start
• Чтение файла конфигурации
• Получение порта 80
• Открытие (создание) логов
• Понижение привилегий
• Запуск дочерних процессов/потоков (*)
• Готов к обработке запроса

Файлы web сервера
• Конфиг /etc/nginx/nginx.conf
include /etc/nginx/sites-enabled/*
• Init-скрипт /etc/init.d/nginx [start|stop|restart]
• PID-файл /var/run/nginx.pid
• Error-лог /var/log/nginx/error.log
• Access-лог /var/log/nginx/access.log

Процессы web сервера
• Master (root, 1 процесс)
• Чтение и валидация конфига
• Открытие сокета (ов) и логов
• Запуск и управление дочерними процессами (worker)
• Graceful restart, Binary updates
• Worker (www-data, 1+ процессов)
• Обработка входящих запросов

Модульная архитектура
• web сервер – не монолитный
• Динамическая загрузка модулей - LoadModule
• Этапы обработки запроса и модули
• Дополнительные директивы, контексты
• Примеры: mod_mime, mod_mime_magic, mod_autoindex,
mod_rewrite, mod_cgi, mod_perl, mod_gzip

Терминология
virtual host, вирт. хост - секция конфига web сервера, отвечающая
за обслуживание определенного домена
location - секция конфига, отвечающая за обслуживание
определенной группы URL

Секции и директивы
• http ― конфигурация для HTTP сервера
• server ― конфигурация домена (вирт. Хоста)
• server_name ― имена доменов
• location ― локейшен, группа URL
• root , alias ― откуда нужно брать файлы
• error_log ― лог ошибок сервера
• access_log ― лог запросов

Приоритеты location в nginx
• location = /img/1.jpg
• location ^~ /pic/
• location ~* \.jpg$
• location /img/
При одинаковом приоритете используется тот location, что
находится выше в конфиге.

Отдача статических документов
location ~* ^.+\.(jpg|jpeg|gif|png)$ {
root /www/images;
}
location /sitemap/ {
alias /home/www/generated/;
}
/2015/10/ae2b5.png → /www/images/2015/10/ae2b5.png
/sitemap/index.xml → /home/www/generated/index.xml

Как узнать атрибуты ?
$ ps -o pid,euser,egroup,comm,args -C nginx
PID EUSER EGROUP COMMAND
29731 root root nginx: master process /usr/sbin/nginx
29732 www-data www-data nginx: worker process
29733 www-data www-data nginx: worker process
29734 www-data www-data nginx: worker process
29737 www-data www-data nginx: worker process
$ ls -lah www/index.html
-rw-r--r-- 1 nuf users 156K Feb 6 21:15 www/index.html

Проверка доступа
Для того, чтобы открыть файл, необходимо иметь права на чтение
r самого файла и на исполнение x директорий, в которых он
находится. Наличие прав проверяется следующим образом:
• Если совпадает пользователь -rw-r--r--
• Если совпадает группа -rw-r--r--
• Иначе -rw-r--r--

Простейший TCP сервер
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('127.0.0.1', 8080))
s.listen(10)
while True:
conn, addr = s.accept()
path = conn.recv(512).decode('utf8').rstrip("\r\n")
file = open('/www' + str(path), 'r')
data = file.read().encode('utf8')
conn.sendall(data)
file.close(); conn.close()

Решение проблемы
• множество потоков - multithreading
• множество процессов - prefork, pool of workers
• комбинированный подход

Плюсы и минусы prefork
➕ простота разработки
➕ можно использовать любые библиотеки
➖ большое потребление памяти: 1 клиент = 1 процесс
➖ проблема с долгоживущими соединениями

Плюсы и минусы multithreading
По сравнению с prefork,
➕ экономия памяти: 1 клиент = 1 поток
➖ требует аккуратной работы с памятью
➖ как следствие, накладывает ограничение на выбор библиотек


Мультиплексирование
readsocks, writesocks = [...], [...] # сокеты
while True:
readables, writeables, exceptions = \
select(readsocks, writesocks, [])
for sockobj in readables:
data = sockobj.recv(512)
if not data:
sockobj.close()
readsocks.remove(sockobj)
else:
print('\tgot', data, 'on', id(sockobj))

Event-driven разработка
• множество открытых файлов
• select, kqueue, epoll, aio...
• последовательное исполнение → события

Плюсы и минусы
➕ быстро, программа не блокируется
➕ экономия памяти: 1 клиент = 1 объект
➕ обработка большого количества клиентов
➕ обработка медленных или долгоживущих соединений
➖ тяжело программировать
➖ использование блокирующих вызовов все портит

Кто есть кто
• Apache – prefork, worker, threads, С
• Tomcat, Jetty – threads, Java
• Starman, Gunicorn – prefork, языки высокого уровня
• Nginx, Lighttpd – асинхронные, С
• Node.JS, Tornado – асинхронные, языки высокого уровня

-------------------------------------------------------------------

1.9 Архитектура frontend-backend
Задачи Frontend (web) сервера
• отдача статических документов
• проксирование (reverse proxy)
• балансировка нагрузки
• кеширование
• сборка SSI
• авторизация, SSL, нарезка картинок, gzip


Reverse proxy
• frontend (медленно) читает запрос от клиента
• frontend (быстро) передает запрос свободному backend
• backend генерирует страницу
• backend (быстро) возвращает ответ frontend серверу
• frontend (медленно) возвращает ответ клиенту
Результат: backend занят минимально возможное время.

Backend (application) сервер
Роль application сервера заключается в исполнении бизнес-логики
приложения и генерации динамических документов.
На каждый HTTP запрос application сервер запускает некоторый
обработчик в приложении. Это может быть функция, класс или
программа, в зависимости от технологии.

Протоколы запуска приложения
• Servlets и др. специализированные API
• mod_perl, mod_python, mod_php
• CGI
• FastCGI
• SCGI
• PSGI, WSGI, Rack

CGI - Common Gateway Interface
• Метод, QueryString, заголовки запроса - через переменные
окружения
• Тело запроса передается через STDIN
• Заголовки и тело ответа возвращаются через STDOUT
• HTTP код ответа передается через псевдозаголовок Status
• Поток ошибок STDERR направляется в лог ошибок сервера

Переменные окружения CGI
• REQUEST_METHOD - метод запроса
• PATH_INFO - путь из URL
• QUERY_STRING - фрагмент URL после ?
• REMOTE_ADDR - IP адрес пользователя
• CONTENT_LENGTH - длина тела запроса
• HTTP_COOKIE - Заголовок Cookie
• HTTP_ANY_HEADER_NAME - любой другой HTTP заголовок

FastCGI и SCGI
Основная проблема CGI - низкая производительность. Протоколы
FastCGI и SCGI призваны решить эту проблему путем демонизации
приложения. Иногда это возможно сделать даже без изменения
кода CGI приложения.


WSGI - актуальный протокол
WSGI, PSGI, Rack - протоколы вызова функции обработчика из
application сервера. Сам application server при этом может
выполняться в отдельном процессе или совпадать с web сервером.
Как правило, при использовании этих протоколов в качестве
application сервера выступает отдельный легковесный процесс.

Web Server Gateway Interface
• Обработчик - функция или класс (callable)
• Метод, QueryString, заголовки запроса - через аргумент environ
• Тело запроса передается через file-handle wsgi.input
• HTTP код ответа и заголовки ответа передаются через вызов
функции start_response
• Тело ответа возвращается в виде списка (iterable) из обработчика
• Поток ошибок должен быть направлен в file-handle wsgi.stderr

Переменные environ
• CGI-like переменные: REQUEST_URI , ...
• wsgi.version - версия WSGI протокола
• wsgi.url_scheme - схема текущего URL: https или http
• wsgi.input - file-handle для чтения тела запроса
• wsgi.errors - file-handle для вывода ошибок
• wsgi.multithreaded - ...
• wsgi.multiprocess - ...

Что ложится на приложение ?
• Анализ PATH_INFO и выбор конкретного обработчика
• Разбор конкретных заголовков, например Cookie
• Разбор QUERY_STRING
• Разбор тела запроса:
• x-www-form-urlencoded
• multipart/form-data
• Вывод правильных заголовков ответа

-------------------------------------------------------------------

2.1 MVC фреймворки
Основные типы запросов
• Запросы статических документов
• Запросы динамических документов
• Отправка данных форм
• A JAX - запросы
• Запросы к API сайта
• Персистентные соединения

Основные задачи
• Маршрутизация URL
• Парсинг заголовков и параметров запроса
• Хранение состояния (сессии) пользователя
• Выполнение бизнес-логики
• Работа с базами данных
• Генерация HTML страницы или JSON ответа

MVC - архитектурный патерн, который задает структуру веб-приложения
из каких частей должно состоять веб приложение и как они должны
между собой взаимодействовать
• Router - выбор конкретного controller по URL
• Model - реализация бизнес-логики приложения
• Controller - работа с HTTP, связь controller и view
• View - генерация HTML или другого представления

Плюсы фреймворков
➕ Готовая архитектура
➕ Повторное использование кода
➕ Экономия ресурсов
➕ Участие в Open Source
➕ Проще найти программистов
➕ Проще обучать программистов


DJANGO
MVC - Django
Model - Model
Router - urls.py
Controller - views
View - templates


Относительные пути
import os.path
BASE_DIR = os.path.abspath(__file__)
BASE_DIR = os.path.dirname(BASE_DIR)
BASE_DIR = os.path.dirname(BASE_DIR)
TEMPLATE_DIRS = (
BASE_DIR + '/templates',
)
STATIC_ROOT = BASE_DIR + '/static'

Паттерн local_settings.py
# в конце project/settings.py
try:
	from ask_pupkin.local_settings import *
except ImportError:
	pass

-------------------------------------------------------------------

2.2 MVC фреймворки
Django Views
Контроллеры в Django - это обычные функции, которые:
• принимают объект django.http.HttpRequest
первым параметром
• возвращают объект django.http.HttpResponse

HttpRequest
• request.method - метод запроса
• request.GET - словарь с GET параметрами
• request.POST - словарь с POST параметрами
• request.COOKIES - словарь c Cookie
• request.FILES - загруженныe файлы
• request.META - CGI-like переменные
• request.session - словарь-сессия (*)
• request.user - текущий пользователь (*)


Декораторы в Python
Декоратор – функция, преобразующая одну функцию в другую.
def double_it(func):
	def tmp(*args):
		return func(*args) * 2
return tmp
@double_it
def mult(a, b):
	return a*b

Декораторы в Django
from django.views.decorators.http import require_POST
@require_POST
def like(request):
pass
• @require_GET – только GET запросы
• @require_POST – только POST запросы
• @login_required(login_url='/login/')
• @csrf_exempt – отключить проверку CSRF

Возможности шаблонизатора
• {% for item in list %}{% endfor %} - итерация по списку
• {% if var %}{% endif %} - условное отображение
• {% include "tpl.html" %} - включение подшаблона
• {{ var }} - вывод переменной
• {{ var|truncatechars:9 }} - применение фильтров
• {# comment #} , {% comment %}{% endcomment %} -
комментарии


Context processors
Context processors - это функции, которые вызываются перед
отрисовкой шаблона и могут добавить данных в контекст.
Настройка TEMPLATE_CONTEXT_PROCESSORS :
• django.core.context_processors.request (request)
• django.core.context_processors.csrf (csrf_token)
• django.core.context_processors.static (STATIC_URL)
• django.contrib.auth.context_processors.auth (user, perms)

Когда не вызываются context
processors ?
render(request, template_name, context) - вызывает.
render_to_response(template_name, context) - не вызывает.

-------------------------------------------------------------------

2.3 Работа с СУБД
Полезные утилиты
• ./manage.py validate - проверить структуру моделей
• ./manage.py syncdb - создать таблицы в базе (1 раз)
• ./manage.py shell - запустить python shell
• ./manage.py dbshell - запустить клиент базы данных

Django Models
ORM - Object relational mapping - библиотек предоставляющая
объектно-ориентированный интерфейс к реляционной базе
данных. Django Models - библиотека ORM в Djnago.
Django - SQL
класс Модели - Таблица
объект модели - строка таблицы
QuerySet - запрос

-------------------------------------------------------------------

2.4 Django модели
Методы QuerySet (chaining)
• filter , exclude - фильтрация, в SQL это WHERE
• order_by - сортировка
• annotate - выборка агрегатов, в SQL это JOIN и GROUP BY
• values - выборка отдельных колонок, а не объектов
• distinct - выборка уникальных значений
• select_related , prefetch_related - выборка из нескольких
таблиц

Синтаксис условий в QuerySet
В методах filter и exclude :
• field = value - точное совпадение
• field__contains = value - суффикс оператора LIKE
• field__isnull , field__gt , field__lte
• relation__field = value - условие по связанной таблице
• category__title__contains = "Perl"
Названия полей и таблиц не могут содержать __ !

-------------------------------------------------------------------

2.5 Отображение данных
Progressive loading
Постраничная загрузка хорошо работает в тех случаях, когда
легко определить число объектов, подходящих под поисковый
запрос. Другими словами - когда можно составить эффективный
SQL запрос.
Иногда это сделать сложно, например: «отображать все посты в
порядке добавления, но не больше одного поста из одной
категории подряд».

class PostManager(models.Manager):
	def main(self, since, limit=10):
		qs = self.order_by('-id')
		res = []
		if since is not None:
			qs = qs.filter('id__lt'=since)
		for p in qs[:1000]:
			if len(res):
				res.append(p)
			elif res[-1].category != p.category:
				res.append(p)
			if len(res) >= limit:
				break
		return res


def post_list_main(request):
	since = request.GET.get('since')
	posts = Post.objects.main(since)
	return render(request, 'blog/post_main.html', {
		'posts': posts,
		'since': posts[-1].id,
	})

<a href="/blog/main/?since={{ since }}">Далее</a>

-------------------------------------------------------------------

2.6 Обработка форм
Перенаправления в HTTP
• 302 Found - временное перенаправление
• 301 Moved Permanently - постоянное перенаправление
(кешируется в браузере)
• Location: url - URL для повторного запроса. Может быть как
абсолютным, так и относительным.

Перенаправления в Django
from django.http import HttpResponseRedirect
def some_view(request):
	# logic..
	return HttpResponseRedirect('/new_url/')
# уязвимость open redirect
def dangerous_view(request):
	url = request.GET.get('continue')
	return HttpResponseRedirect(url)

-------------------------------------------------------------------

2.7 Сессии и авторизация
Атрибуты Cookie
• name=value - имя и значение cookie
• Expires - время жизни cookie, по умолчанию - до закрытия окна.
• Domain - домен cookie, по умолчанию - домен текущего URL.
• Path - путь cookie, по умолчанию - путь текущего URL.
• Secure - cookie должна передаваться только по https
• HttpOnly - cookie не доступна из JavaScript

Установка и удаление Cookies
Set-Cookie: sessid=d232rn38jd1023e1nm13r25z;
Domain=.site.com; Path=/admin/;
Expires=Sat, 15 Aug 2015 07:58:23 GMT;
Secure; HttpOnly
Set-Cookie: lang=ru
Set-Cookie: sessid=xxx;
Expires=Sun, 06 Nov 1994 08:49:37 GMT
Для удаления cookie, сервер устанавливает Expires в прошлом.

Получение Cookies
Cookie: sessid=d232rn38jd1023e1nm13r25z; lang=ru;
csrftoken=vVqoyo5vzD3hWRHQDRpIHzVmKLfBQIGD;
При каждом запросе браузер выбирает подходящие cookies и
отправляет только их значения.

Правила выбора Cookies
Пусть URL= http://my.app.site.com/blog/post/12
Браузер выберет все cookies, у которых:
• Не истек срок Expires
• Domain совпадает с my.app.site.com или является .суффиксом,
например Domain=.site.com
• Path является префиксом /blog/post/12 ,
например Path=/blog/
• Не стоит флага Secure

Работа с cookie в Django
# установка
resp.set_cookie('sessid','asde132dk13d1')
resp.set_cookie('sessid','asde132dk13d1',
domain='.site.com', path='/blog/',
expires=(datettime.now() + timedelta(days=30)))
# удаление
resp.delete_cookie('another')
# получение
request.COOKIES # все cookies
request.COOKIES.get('sessid') # одна cookie

Cookie-based авторизация
Необходимые модели
class User(models.Model):
	login = models.CharField(unique=True)
	password = models.CharField()
	name = models.CharField()
class Session(models.Model):
	key = models.CharField(unique=True)
	user = models.ForeignKey(User)
	expires = models.DateTimeField()

def login(request):
	error = ''
	if request.method == 'POST':
		login = request.POST.get('login')
		password = request.POST.get('password')
		url = request.POST.get('continue', '/')
		sessid = do_login(login, password)
		if sessid:
			response = HttpResponseRedirect(url)
			response.set_cookie('sessid', sessid,
				domain='.site.com', httponly=True,
				expires = datetime.now()+timedelta(days=5)
			)
			return response
		else:
			error = u'Неверный логин / пароль'
	return render(request, 'login.html', {'error': error })

def do_login(login, password):
	try:
		user = User.objects.get(login=login)
	except User.DoesNotExist:
		return None
	hashed_pass = salt_and_hash(password)
	if user.password != hashed_pass
		return None
	session = Session()
	session.key = generate_long_random_key()
	session.user = user
	session.expires = datetime.now() + timedelta(days=5)
	session.save()
	return session.key

Middleware в Django
Middleware - это Python класс, в котором есть один из указанных
ниже методов. Список всех активных middleware указан в
настройке MIDDLEWARE_CLASSES .
• process_request(request)
• process_view(request, view, args, kwargs)
• process_response(request, response)
• process_exception(request, exception)

class CheckSessionMiidleware(class):
	def process_request(request):
		try:
			sessid = request.COOKIE.get('sessid')
			session = Session.objects.get(
				key=sessid,
				expires__gt=datetime.now(),
			)
			request.session = session
			request.user = session.user
		except Session.DoesNotExist:
			request.session = None
			request.user = None

Выход из приложения
Для выхода из приложения достаточно удалить объект сессии:
def logout(request):
	sessid = request.COOKIE.get('sessid')
	if sessid is not None:
		Session.objects.delete(key=sessid)
	url = request.GET.get('continue', '/')
	return HttpResponseRedirect(url)


django.contrib.sessions
Предоставляет поддержку сессий, в том числе анонимных.
Позволяет хранить в сессии произвольные данные, а не только ID
пользователя. Позволяет хранить сессии в различных
хранилищах, например Redis или Memcached.
def some_view(request):
	val = request.session['some_name']
	request.session.flush()
	request.session['some_name'] = 'val2'

Безопасность сессий
Основное направление атаки - кража cookie, хранящей ключ
сессии, т.е. кража авторизации. Меры безопасности:
• Ключ сессии невозможно подобрать перебором
• HttpOnly флаг для сессионной cookie
• Привязка сессии к IP адресу
• Ограничение сессий по времени
• Запрос пароля при критических действиях: смене пароля и т.д.

-------------------------------------------------------------------

3.1 Технология AJAX
Asynchronous JavaScript And XML
AJAX - технология загрузки данных / отправки форм без
обновления WEB страницы.
XML - совершенно не обязателен, возможны отправка и прием
данных любого типа. Чаще всего вместо XML используется HTML
либо JSON для загрузки сырых данных.

AJAX на стороне клиента
var xhr = new XMLHttpRequest();
xhr.open('POST', '/xhr/test.html', true);
xhr.onreadystatechange = function() {
	if (xhr.readyState == 4) {
		if (xhr.status == 200) {
			alert(xhr.responseText);
		}
	}
};
xhr.send("a=5&b=4");

AJAX при помощи jQuery
$.ajax({
	url: '/blog/comments/add/',
	type: 'POST',
	data: { post_id: 12, text: 'Занятная идея!' },
}).success(function(data) {
	if (data.status == 'ok') {
		console.log(data.comment_id);
	}
}).error(function() {
	console.log('http error')
});

Особенности и ограничения AJAX
• Same Origin Policy - AJAX запросы можно отправлять только на
свой домен. В современных браузерах есть CORS.
• Т.к. данные передаются явно в метод send , то нельзя загружать
файлы. В HTML5 есть FormData.
• AJAX на стороне сервера не отличим от обычного запроса. jQuery
добавляет заголовок X-Requested-With: XMLHttpRequest
• Результаты запроса передаются в JavaScript функцию поэтому
стандартные методы обработки ошибок - не работают.

Загрузка HTML данных
def comments_list(request):
	post_id = request.GET.get('post_id')
	post = get_object_or_404(Post, post_id)
	comments = paginate(request, post.comments)
	return render(request, 'blog/comments.html', {
		'comments': comments
	})
В blog/comments.html отображается только HTML код
комментариев, без окружающей страницы.

Обмен данными в JSON
{
	"status": "ok",
	"comment_id": 123
}
{
	"status": "error",
	"code": "no_auth",
	"message":"вы не авторизованы"
}

HttpResponseAjax
import json
class HttpResponseAjax(HttpResponse):
	def __init__(self, status='ok', **kwargs):
		kwargs['status'] = status
		super(HttpResponseAjax, self).__init__(
			content = json.dumps(kwargs),
			content_type = 'application/json',
		)
class HttpResponseAjaxError(HttpResponseAjax):
	def __init__(self, code, message):
		super(HttpResponseAjaxError, self).__init__(
			status = 'error', code = code, message = message
		)

@login_required_ajax
def comment_add(request):
	form = AddCommentForm(request.POST)
	if form.is_valid():
		comment = form.save()
		return HttpResponseAjax(comment_id=comment.id)
	else:
		return HttpResponseAjaxError(
			code = "bad_params",
			message = form.errors.as_text(),
		)

Проверка авторизации в AJAX
def login_required_ajax(view):
	def view2(request, *args, **kwargs):
		if request.user.is_authenticated():
			return view(request, *args, **kwargs)
		elif request.is_ajax():
			return HttpResponseAjaxError(
				code = "no_auth",
				message = u'Требуется авторизация',
			)
		else:
			redirect('/login/?continue=' + request.get_full_path())
	return view2

Cross Origin Resource Sharing
Браузер выполняет AJAX запросы даже к чужому домену, но в этом
случае не вызывает функцию-callback в JavaScript, т.е. не дает
использовать данные, загруженные с чужого домена.
CORS позволяет серверу явно разрешить использование данных
при кросс-доменных запросах.

Заголовки CORS
• Origin - указывает URL запрашивающего приложения
• Access-Control-Allow-Origin: origin - разрешает
использовать данные в кросс-доменном запросе. origin должен
либо совпадать с загловком Origin в запросе, либо * .
• Access-Control-Allow-Credentials - позволяет использовать
данные, если были переданы cookies.

Использование CORS
Не следует разрешать CORS для всех запросов ( * ).
Хорошей практикой является:
• Проверка суффикса домена
• Проверка домена по списку доверенных

CORS на клиенте
$.ajax({
	url: 'https://site.com/blog/comments/add/',
	type: 'POST',
	data: { post_id: 12, text: 'Занятная идея!' },
	crossDomain: true,
	xhrFields: {
		withCredentials: true
	}
}).success(function(data) {
	// ...
});

CORS на сервере
def allow_cors(view):
	def view2(request, *args, **kwargs):
		response = view(request, *args, **kwargs)
		origin = request.META.get('HTTP_ORIGIN')
		if not origin:
			return response
		for domain in settings.CORS_WHITE_LIST:
			if origin.endswith('.' + domain):
				response['Access-Control-Allow-Origin'] = origin
		return response
	return view2

-------------------------------------------------------------------

3.2 Real-Time сообщения
Примеры использования
• Чаты и мессенджеры
• Отображение котировок
• Прямые трансляции (a-la twitter)
• Push уведомления
• Сетевой обмен в играх на HTML

• Polling - периодический опрос сервера
• Comet (Long polling) - polling с долгоживущими запросами
• Server Push - бесконечный запрос
• WebSocket - специализированный протокол

Polling на клиенте
var since = 0;
setInterval(function() {
	$.ajax({
		type: 'GET',
		url: '/get_messages/',
		data: { channel_id: 5, since: since },
	}).success(function(resp) {
		if (!resp.messages || !resp.messages.length) {
			return;
		}
		handleMessages(resp.messages);
		since = resp.messages[0].id;
	});
}, 5000);

Polling на сервере
def get_messages(request):
	chan_id = request.GET.get('channel_id')
	since = request.GET.get('since', 0)
	messages = Messages.filter(
		channel_id = channel_id,
		id__gt = since,
	).order_by('-id')
	messages = [ m.as_data() for m in messages ]
	return HttpResponseAjax(messages = messages)

➕ Простота и надежность реализации
➕ Не требуется дополнительного ПО
➖ Сообщения приходят с задержкой до N секунд
➖ Избыточное число HTTP запросов RPS=CCU/N
➖ Ограничение по числу пользователей


Comet на клиенте
function getComet() {
	$.ajax({
		type: 'GET',
		url: '/get_messages/',
		data: { channel_id: 5 },
	}).success(function(resp) {
		handleMessages(resp.messages);
		getComet();
	}).error(function() {
		setTimeout(getComet, 10000);
	});
}
getComet();

Comet на сервере
В технологии comet сервер должен поддерживать одновременно
открытыми большое количество соединений, причем каждое
соединение находится в ожидании сообщений для него. По этой
причине мы не можем использовать классический applicationсервер в роли comet-сервера. Для comet-сервера необходима
отдельная технология, например nginx + mod_push.

Nginx + mod_push
location /publish/ {
	set $push_channel_id $arg_cid; # id канала
	push_store_messages off; # не храним сообщения
	push_publisher; # включаем отправку
	allow 127.0.0.1;
	deny all;
}

location /listen/ {
	push_subscriber_concurrency broadcast; # всем!
	set $push_channel_id $arg_cid; # id канала
	default_type application/json; # MIME тип сообщения
	push_subscriber; # включаем доставку
}

Отправка сообщений
import urllib2
import json
def send_message(request):
    cid = request.GET.get('to') # в видео проясняется что здесь использование GET ошибочно
    text = request.GET.get('text')
    url = 'http://127.0.0.1/publish/?cid=' + cid
    body = json.dumps({ 'messages': [ text ] })
    request = urllib2.Request(url, body, {})
    response = urllib2.urlopen(request) # может быть долгим
    if response.getcode() == 200:
        return HttpResponseAjax()
    else:
        return HttpResponseAjaxError(code=response.getcode())

Плюсы и минусы Comet
➕ Поддержка всеми браузерами
➕ Поддержка большого числа пользователей
➕ Относительная простота реализации
➖ Избыточные HTTP запросы
➖ Half-duplex


Server push - бесконечный запрос
Server push на клиенте
<script>
	function handle(message) {
		// любая логика
	}
</script>
<iframe src='/messages/?cid=123'></iframe>
Ответ сервера:
<script>parent.handle({ message: 'hello' })</script>


WebSocket
WebSocket handshake
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat

WebSocket на стороне клиента
var socket = new WebSocket('ws://host/echo');
socket.onopen = function(event) {
	console.log('ws opened');
	var data = JSON.stringify({ message: "Hello WebSocket" });
	socket.send(data);
};
socket.onmessage = function(event) {
	var resp = JSON.parse(event.data);
	console.log('ws message', resp.message);
};
socket.onclose = function(event) {
	console.log('ws closed')
};

WebSocket на стороне сервера
registry = {}
class WSHandler(tornado.websocket.WebSocketHandler):
	def open(self):
		self.uid = self.get_argument("uid")
		registry[self.uid] = self
	def check_origin(self, origin):
		return True
	def on_close(self):
		del registry[self.uid]

WebSocket на стороне сервера (2)
class MainHandler(tornado.web.RequestHandler):
	def post(self):
		body = self.get_argument("msg")
		uid = self.get_argument("uid")
		conn = registry.get(uid)
		if conn:
			conn.write_message(body)
			self.write("OK")
		else:
			self.write("NO")

WebSocket на стороне сервера (3)
if __name__ == "__main__":
	app = tornado.web.Application([
		(r"/pub", MainHandler),
		(r"/sub", WSHandler),
	])
app.listen(8888)
tornado.ioloop.IOLoop.current().start()

Плюсы и минусы WebSocket
➕ Минимальный объем трафика
➕ Минимальная нагрузка на сервер
➕ Поддержка большого числа пользователей
➕ Full-duplex
➖ Нет поддержки IE<10, OperaMini, Android<4.4
➖ Требуется специальный WebSocket-сервер
➖ Плохо работает с прокси-серверами

-------------------------------------------------------------------