1.4
mkdir - создать директорию
touch - создать файл
cd 
ls -l
pwd
man команда - вывести мануал по команде
команда -h - лучше так 

rm
rm -r - удалить директорию
rm -rf - удалить директорию без повросов
cp - копировать содержимое файла
cp -r - копировать дир1 в дир2
mv - move - переместить

1.5
Запуск исполняемых файлов
chmod +x - сделать файл исполняемым
Запуск, Ctrl+C - остановить
Запуск, Ctrl+Z - поставить на паузу
Запуск, Ctrl+Z, bg - после паузы запустить в бэкграудне
Запуск, Ctrl+Z, fg - после паузы запустить в фронт

1.6
cat - вывести содержимое
less - открыть файл на чтение (q - выход /-поиск g-в начало G-в конец
nano - редактировать файл ctrl+x - выход

Программа<файл
	брать stdin из файла
Программа<файл
	выводить stdout в файл
Программа>>файл
	с дозаписью в файл
Программа2>файл
	выводить stderr в файл
Программа2>>файл
	с дозаписью в файл

Конвейер (pipe)
Прог|Прог2|...ПрогN
	передать stdout Прог1 в качестве
	stdin для Прог2 и т.д

1.7
wget ссылка
	скачать файл по ссылке и сохранить в
	текущей директории
wget -P путь_до_директории ссылка
	скачать файл по ссылке и сохранить в
	директории заданной путем
wget -O путь_до_файла ссылка
	скачать файл по ссылке и сохранить под
	указанным именем

wget -c ссылка
	докачать файл по ссылке в случае
	обрыва связи
wget --spider ссылка
	проверить доступность файла по
	ссылке
wget -i текстовый_файл
	скачать несколько файлов по ссылкам
	из текстового файла

wget -r -l глубина ссылка
	рекурсивное скачивание файлов по
	ссылке на указанную глубину
	(по умолчанию глубина 5)
wget -r -A тип,тип,...,тип ссылка
	рекурсивное скачивание файлов только
	определенного типа (типов)

1.8
Распаковка архивов:
unzip архив.zip
	распаковать содержимое архива.zip
gunzip архив.gz
	распаковать содержимое архива.gz,
	файл архив.gz удалить

Создание архивов:
zip архив.zip файл1 файл2 ...
	запаковать перечисленные файлы
	и/или папки в архив.zip
gzip файл
	запаковать файл в файл.gz, исходный
	файл удалить
Создание архивов:
tar -cvf архив.tar файл1 файл2 ...
	запаковать перечисленные файлы
	и/или папки в архив.tar (без сжатия)
gzip архив.tar
	запаковать архив.tar в архив.tar.gz,
	исходный архив.tar удалить

tar -zcvf архив.tar.gz файл1 файл2 ...
	запаковать перечисленные файлы
	и/или папки в архив.tar.gz (c сжатием
	при помощи gzip)

Распаковка архивов:
tar -xvf архив.tar
	распаковать архив.tar
tar -xzvf архив.tar.gz
	распаковать архив.tar.gz
	(с использованием gunzip)

Еще один архиватор:
bzip2 файл
bunzip2 файл.bz2
tar -cjvf архив.tar.bz2 файл1 файл2 ...
tar -xjvf архив.tar.bz2
 
Сжатие/распаковка без удаления:
gzip -c файл > файл.gz
gunzip -c файл.gz > файл
bzip2 -c файл > файл.bz2
bunzip2 -c файл.bz2 > файл

1.9
find <папка> -name “<имя файла>”
	найти указанный файл в папке
find <папка> -name “<имя файла>”
	найти указанный файл в папке
find ~/ -name “file.txt”
	найти file.txt в домашней директории
find ~/ -name “*.txt”
	найти все текстовые файлы в домашней
	директории

grep “<строка>” <файл>
	найти строку в файле
grep -с “<строка>” <файл>
	посчитать количество вхождений строки
grep -r “<строка>” <папка>
	найти строку во всех файлах в папке
grep “hello” file.txt
	найти “hello” в файле file.txt
grep -с “123” file.txt
	вывести количество раз, которое “123”
	встречается в file.txt
grep -r “world” ~/
	найти “world” во всех файлах в домашней
	директории

2.1
Для входа на сервер, нужно знать:
1) адрес сервера,
2) логин и пароль
Команда входа:
ssh логин@адрес_сервера -p порт
Создание ключа:
ssh-keygen
Сообщить системе о ключе:
ssh-add
Просмотр публичного ключа:
cat ~/.ssh/id_rsa.pub
Редактирование авторизованных
ключей (на сервере):
nano ~/.ssh/authorised_keys

2.2
Копирование файлов:
scp -P порт
логин@адрес_сервера:путь1 путь2
	с сервера (путь1) на клиента (путь2)
scp -P порт
путь1 логин@адрес_сервера:путь2
	с клиента (путь1) на сервер (путь2)

Установка программ через терминал:
sudo apt-get install программа
Удаление программ через терминал:
sudo apt-get remove программа

Обновление ссылок на пакеты:
sudo apt-get update
Обновление установленных пакетов:
sudo apt-get upgrade
Обновление отдельной программы:
sudo apt-get install --only-upgrade программа

2.4
Ctrl + C прервать выполнение
Ctrl + Z приостановить выполнение:
	fg продолжить (foreground)
	bg продолжить в фоновом
	 режиме (background)

jobs
	посмотреть запущенные программы
fg %<номер>
	продолжить программу с этим номером
bg %<номер>
	продолжить программу с этим номером в
	фоновом режиме 

ps
	посмотреть ваши процессы
top
	отслеживать процессы в реальном
	времени
top -u <имя пользователя>
	отслеживать процессы этого
	пользователя 

kill <номер процесса>
	завершить процесс с этим номером
kill -9 <номер процесса>
	“убить” процесс с этим номером

2.5
free -g
	информация об оперативной памяти
nproc
	количество ядер процессора
lscpu
	детальная информация о процессоре

bowtie2-build
	запуск построения индекса генома
bowtie2-build <геном> <индекс>
bowtie2-build ref.fasta index

bowtie2
	запуск выравнивателя bowtie
bowtie2 -x <индекс> -U <риды>
	-p <количество потоков>
bowtie2 -x index -U reads.fastq

2.6
Ctrl + Shift + T
	открыть новую вкладку в терминале
Alt + <цифра>
	перейти в указанную вкладку
Ctrl + Shift + W
	закрыть текущую вкладку

tmux
	запустить tmux
Ctrl + B
	перейти в режим команд
Ctrl + B и C (зажать Ctrl+B, отпустить,
затем нажать С)
	создать новую вкладку
Ctrl + B и <цифра>
	перейти в указанную вкладку
Ctrl + B и N / Ctrl + B и P
	перейти в следующую / предыдущую
	вкладку
Ctrl + B и X (или exit)
	закрыть вкладку
Ctrl + B и D
	временно выйти из tmux
tmux attach / tmux a
	вернуться в tmux
tmux list-sessions
	посмотреть список запущенных tmux’ов
Ctrl + B и PgUp
	перейти в режим просмотра истории
PgUp, PgDown, стрелки
	перемещать курсор по истории
Esc, Ctrl + C
	выйти из режима просмотра истории

3.1
	Редактор Vim
Вход:
vim
vim файл
vim файл1 файл2 файл3 ...
	Главные команды:
:q выход
:help справка

	vimtutor - автотуториал

	Режимы работы
1. normal
- Режим по умолчанию
- Любая клавиша воспринимается как команда
- «Сложные» команды начинаются с ‘:’
2. insert
- Режим ввода текста — все, что вы
нажимаете, вставляется (заменяется).
- Выход через <Esc>, <Ctrl+c>
3. visual
- Режим выделения

	Перемещение
По символам:
Стрелочки
h,j,k,l
По словам:
w, W — в начало следующего слова
e, E — в конец
b, B — в начало предыдущего
Еще крупнее:
0,^,$ — начало строки, первый непробельный
символ, конец строки
Совсем крупно:
 gg— начало файла
 G — конец
 :21<Enter> — перейти к строке 21
 <Ctrl+D>, <Ctrl+U> — вниз/вверх на N
строчек, где N обычно пол-экрана

	Удаление
По символам:
x — символ под курсором
X — символ до курсора
Сразу много: d [<кол-во>] <ход>
dе — удалить до конца текущего слова
d$ — удалить до конца строки
d5w — удалить пять слов
Специальная команда:
dd — удалить строку (или, например, d10d)

	Создание
i — войти в insertion mode
a — сдвинуть курсор вправо и войти в
insertion mode
I = ^i
A = $a
o — вставить пустую строку снизу и
редактировать ее
O — то же, но строка сверху

	Копирование
Скопировать:
y <кол-во> <ход> — скопировать
yy — скопировать строку
Вставить:
p — вставить после
P — вставить перед

	Поиск и замена
Поиск:
/<текст> — искать <текст> вперед
?<текст> — назад
n — следующее вхождение, N —
предыдущее
Замена:
:%s/<что ищем>/<на что меняем>/<флаги>
флаги: g – много замен в строке, с –
подтверждение

	Полезные команды
Отмена/возврат:
u — отменить последнее действие
<Ctrl+r> — вернуть отмененное действие
Сохранение работы:
:w — сохранить изменения
:wq — сохранить и выйти
:q! — выйти без сохранения
:w <файл> — сохранить изменения в <файл>


3.2 
	Программирование на bash
оболочка (shell) –
	интерпретатор команд
sh (Bourne shell) – стандарт и доступна почти в любом
	дистрибутиве (1977)
bash (Bourne again shell) – усовершенствованная и
	модернизированная вариация sh (1989)
csh, tcsh, zsh, ...

Первая программа
	Создаем программу:
vim my_first_script.sh
#!/bin/bash
echo "Hello, world!"
	Запускаем программу:
chmod +x my_first_script.sh
./my_first_script.sh

	Переменные
Переменная (variable)
 	именованная область памяти
имя (name):
	буквы, цифры, _;
	не может начинаться с цифры.
значение (value):
	числа;
	строки (если есть пробелы, то в кавычках);
	отдельные символы.

Запись (перезапись) значения:
<имя>=<значение>
path=~/Docs
Чтение:
$<имя> или ${<имя>}
path2=$path/file1.txt # path2=~/Docs/file1.txt
echo “Path is $path2” # Path is ~/Docs/file1.txt
echo “Path is ${path}2” # Path is ~/Docs2

	Аргументы
Передача аргументов скрипту:
./script.sh arg1 arg2 arg3 ...
Обработка внутри скрипта:
$1 первый аргумент
$2 второй аргумент
….
$0 имя скрипта
$# количество аргументов
var=”Первый аргумент равен $1”
echo ”Всего было передано $# аргументов” 

3.2 - 3.4 


3.5
find -iname “<имя файла>”
	не учитывать регистр
find -path “<путь>”
	найти указанный путь
find -size <размер>
	выводить файлы указанного размера 
find -maxdepth <число>
	искать не больше чем на заданное число
	уровней вниз
find -mindepth <число>
	искать начиная с заданного числа
	уровней вниз
grep -l “<строка>” <файл>
	список файлов с этой строкой
grep -L “<строка>” <файл>
	список файлов, где этой строки нет
grep -n “<строка>” <файл>
	выводить номер строки в файле
grep -m <число> “<строка>” <файл>
	не искать дальше после заданного числа
	вхождений
grep -A <число> “<строка>” <файл>
	выводить это число строк после
	вхождения
grep -B <число> “<строка>” <файл>
	выводить это число строк до вхождения
grep -C <число> “<строка>” <файл>
	выводить это число строк вокруг
	вхождения
grep -E “<шаблон>” <файл>
	найти указанный шаблон в файле
grep -E “^go” <файл>
	найти строки, начинающиеся с “go”
grep -E “go$” <файл>
	найти строки, оканчивающиеся на “go"
grep -E “c[au]t” <файл>
	найти все слова, содержащие cut и cat
grep -E “ [a-z]ight ” <файл>
	слова из 5 букв, кончающиеся на “ight”
grep -E “ [a-z]*ight ” <файл>
	слова из 4 и более букв,
	кончающиеся на “ight” 
grep -E “ [a-z]+ight ” <файл>
	слова из 5 и более букв,
	кончающиеся на “ight”
grep -E “ [a-z]?ight ” <файл>
	слова из 4-5 букв, кончающиеся на “ight”
grep -E “ [a-zA-Z]*ight ” <файл>
	слова, кончающиеся на “ight”
	(разрешены большие буквы)
cat <файл> | sed ‘инструкция’
sed ‘инструкция’ <файл>
	потоковый редактор: читает строчки из
stdin (или из файла), обрабатывает их по
	инструкции и пишет в stdout
	Если хотим писать в файл:
> <файл> обычное перенаправление
-i, --in-place перезаписать входной файл
sed ‘s/John/Nick/g’ old.txt > new.txt
	заменить все John на Nick
sed -r ‘s/J[a-z]*n/Nick/g’ old.txt > new.txt
	заменить все слова, которые начинаются
	на J и кончаются на n на Nick
sed -n ‘2,4p’ file.txt
	вывести строки с 2 по 4
sed ‘2,4d’ file.txt
	вывести все строки кроме 2-4
sed -n ‘/[0-9]\{2\}/p’ file.txt
	вывести строки с 2 цифрами подряд
sed '2,/[Rr]ight/d' file.txt
	вывести все строки кроме со 2 до строки
	содержащей “right” (с большой или
	маленькой буквы)

3.6
	gnuplot
 программа для построения графиков
режимы работы:
- интерактивный
- потоковый

	Интерактивный режим
plot '<файл>' using 1:2
 	построить график по файлу; первая
колонка -- координата х, вторая -- у
set title '<название>'
	добавить название графика
set xlabel '<название>'
set ylabel '<название>'
 	добавить названия осей
plot '<файл>' using 1:2 title ‘<название>’
 	добавить название ряду данных
set key autotitle columnhead
 	брать название ряда данных из первой
	строчки файла
set xtics <число>
set ytics <число>
	установить количество отсечек на осях
set xrange [от:до]
set yrange [от:до]
	установить границы значений на осях
set xtics('0' 0.0, '1/4' 0.25, '1/2' 0.5, '1' 1.0,)
	задать конкретные надписи на отсечках
set logscale y
	логарифмическая шкала для оси OY
set autoscale xy set autoscale xmin
unset autoscale z
	автомасштабирование осей
plot '<файл>' using 1:2 smooth csplines
with lines lt -1
 	построить сглаженную (smooth) методом
csplines линию типа (lt) -1 (черный цвет)
plot '<файл>' using 1:2 with points
pointsize 1 pointtype 10 lt 1

	Потоковый режим
	Создаем скрипт:
#! /usr/bin/gnuplot -persist
set terminal png enhanced
set output "plot.png"
set …
plot ...
	Запускаем:
gnuplot --persist <имя_скрипта>
chmod +x <имя_скрипта>
./<имя_скрипта>

3.7
Права доступа
Узнать кто сейчас в системе:
users
Узнать какие вообще есть пользователи:
less /etc/passwd
 syslog:x:100:103::...
bi:x:1000:1000:bi,,,...(UID >= 1000)
Узнать группы пользователя:
groups <имя_пользователя>

Узнать права доступа:
ls -l <путь>
drwxrwxr-x 2 user group ... dir
-rw-rw-r-- 1 user group ... file

	Права у файлов:
r – просмотр содержимого
w – редактирование
x – запуск
	Права у директорий:
r – просмотр содержимого
w – создание/удаление файлов/поддиректорий
x – 	1) вход в директорию
 	2) просмотр inode файлов/поддиректорий

	Изменить права доступа:
chmod [ugoa][+-][rwx] <путь>
chmod ug+rw file.txt
chmod [octal code] <путь>
chmod 777 file.txt
	Изменить обладателя:
chown new_user:new_group <путь>
chown zoidberg file.txt
chown :futurama file.txt

	Cуперпользователь:
root (группа root)
	Сделать от имени root:
sudo <действие>
sudo mkdir dir
sudo chmod -r dir

	Посчитать что-то в файле:
wc [что-считаем] <путь>
wc -l file.txt
wc -w file.txt
wc -c file.txt
	Сравнить файлы/директории:
diff [-q -r] <путь1> <путь2>
diff file1.txt file2.txt | less
diff -qr dir1/ dir2/

	Узнать сколько места занимаем на диске:
du [--max-depth <глубина> -h] <путь>
du -h ~/
du –-max-depth 1 -h .
df [-h]
	узнать сколько места занято/свободно
	во всей системе

	Вывести часть файла:
head [-n <количество строк>] <путь>
tail [-n <количество строк>] <путь>
head -n 10 file.txt
tail -n 50 file.txt | less

	Работа с файлами/директориями:
можно использовать {имя1,имя2,...}
mkdir ./{dir1,dir2,dir3}
touch ~/{file1,file2}.txt
	Вывод с сортировкой:
ls --sort=[вид сортировки] -l <путь>
ls –-sort=size -l ~/
ls –-sort=time -l .

	Перенаправление в один файл:
&> или &>>
program &>> both.txt
	Перенаправление одного потока в другой:
2>&1 stderr в stdout
1>&2 stdout в stderr
	Перенаправление в никуда и из ниоткуда:
/dev/null
program 2>/dev/null
cat /dev/null > file.txt