===============================================================================

1.1 Введение
Selenium WebDriver — универсальный интерфейс, который позволяет 
манипулировать разными браузерами напрямую из кода на языке 
программирования. 

1.4 Поиск элементов
По id - #id
По class - .class
Поиск по tag - h1
Поиск по значению атрибута - [id="bullet"], [value="Cat memes"]
Использование потомков id post2 class title - #post2.title
Поиск всех id posts с классом title - #posts .title (главное пробел)
Использование дочерних элементов - #post2 > div.title тоже самое для post2
Использование порядкового номера дочернего элемента - 
 #posts > .item:nth-child(2) > .title -  :nth-child(2) — позволяет найти 
 второй по порядку элемент среди дочерних элементов для "#posts"


XPath(XML Path Language) - это язык запросов, который использует древовидную 
структуру документа. 
/ это >, а // это пробел
el1/el2 — выбирает элементы el2, являющиеся прямыми потомками el1;
el1//el2 — выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.

Символ [ ] — это команда фильтрации
по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с летящим котом, для этого можно выполнить запрос //img[@id='bullet']
по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath — это единственный способ найти элемент по внутреннему тексту. Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"]. Такой селектор вернет элемент, только если текст полностью совпадет. Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, особенно в случае мультиязычных сайтов.
по частичному совпадению текста или атрибута. Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat. Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения (но вообще не стоит, наверное). Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']

Символ * — команда выбора всех элементов
//div/*[@class="jumbotron-heading"]

1.6 Поиск элементов с помощью Selenium
find_element_by_id — поиск по уникальному атрибуту id элемента.
find_element_by_css_selector — поиск элемента с помощью правил на основе CSS.
find_element_by_xpath — поиск с помощью языка запросов XPath
find_element_by_name — поиск по атрибуту name элемента;
find_element_by_tag_name — поиск элемента по названию тега элемента;
find_element_by_class_name — поиск по значению атрибута class;
find_element_by_link_text — поиск ссылки на странице по полному совпадению;
find_element_by_partial_link_text — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

find_element()
Пример find_element(By.ID, "submit_button")
By.ID – поиск по уникальному атрибуту id элемента;
By.CSS_SELECTOR – поиск элементов с помощью правил на основе CSS;
By.XPATH – поиск элементов с помощью языка запросов XPath;
By.NAME – поиск по атрибуту name элемента;
By.TAG_NAME – поиск по названию тега;
By.CLASS_NAME – поиск по атрибуту class элемента;
By.LINK_TEXT – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
By.PARTIAL_LINK_TEXT – поиск ссылки по частичному совпадению текста.

===============================================================================